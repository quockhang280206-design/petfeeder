<script>
  // =======================
  // CONFIG (gi·ªØ m√¥ ph·ªèng UI)
  // =======================
  const CONFIG = {
    totalCapacity: 1000,
    errorThreshold: 50,
    gramsPerServoRotation: 10
  };

  let systemData = {
    currentFood: CONFIG.totalCapacity,
    todayFeedings: [],
    schedules: [],
    connectionStats: {
      lastPing: 0,
      startTime: Date.now()
    }
  };

  // ============
  // LocalStorage
  // ============
  function loadData() {
    const saved = localStorage.getItem('petfeeder_data');
    if (saved) {
      try {
        const data = JSON.parse(saved);
        const today = new Date().toDateString();

        if (data.lastDate !== today) {
          systemData.todayFeedings = [];
          systemData.currentFood = CONFIG.totalCapacity;
        } else {
          systemData.currentFood = data.currentFood ?? CONFIG.totalCapacity;
          systemData.todayFeedings = data.todayFeedings ?? [];
          systemData.schedules = data.schedules ?? [];
        }
      } catch (e) {
        console.error('Error loading data:', e);
      }
    }
    updateAllDisplays();
  }

  function saveData() {
    const dataToSave = {
      currentFood: systemData.currentFood,
      todayFeedings: systemData.todayFeedings,
      schedules: systemData.schedules,
      lastDate: new Date().toDateString()
    };
    localStorage.setItem('petfeeder_data', JSON.stringify(dataToSave));
  }

  // =======================
  // Slider (UI portion)
  // =======================
  const portionSlider = document.getElementById('portionSlider');
  const portionDisplay = document.getElementById('portionDisplay');
  portionSlider.addEventListener('input', function () {
    portionDisplay.textContent = this.value + 'g';
  });

  // =======================
  // ESP32 API helpers
  // =======================
  async function apiStatus() {
    const t0 = performance.now();
    const r = await fetch('/api/status', { cache: 'no-store' });
    const t1 = performance.now();
    const j = await r.json();
    systemData.connectionStats.lastPing = Math.round(t1 - t0);
    return j;
  }

  async function apiFeed() {
    const r = await fetch('/api/feed', { method: 'POST' });
    return await r.json();
  }

  function setOnlineUI(isOnline) {
    const badge = document.getElementById('statusBadge');
    if (isOnline) {
      badge.textContent = 'Online';
      badge.classList.remove('status-offline');
      badge.classList.add('status-online');
    } else {
      badge.textContent = 'Offline';
      badge.classList.remove('status-online');
      badge.classList.add('status-offline');
    }
  }

  async function refreshFromESP() {
    try {
      const st = await apiStatus();
      setOnlineUI(true);

      // ping + lastUpdate l·∫•y t·ª´ ESP32
      document.getElementById('pingTime').textContent = systemData.connectionStats.lastPing;
      document.getElementById('lastUpdate').textContent = st.time || '---';

      // (t√πy ch·ªçn) n·∫øu mu·ªën hi·ªán IP t·ª´ ESP32:
      // console.log('ESP IP:', st.ip);

    } catch (e) {
      setOnlineUI(false);
      // gi·ªØ l·∫°i s·ªë ping c≈©, nh∆∞ng b√°o offline
    }
  }

  // =======================
  // M√¥ ph·ªèng (gi·ªØ l·∫°i ƒë·ªÉ th·ªëng k√™ UI)
  // =======================
  function simulateServoFeeding(targetPortion) {
    let actualAmount = 0;
    let servoRotations = 0;
    let foodReductions = 0;

    while (actualAmount < targetPortion) {
      servoRotations++;
      const foodReleased = CONFIG.gramsPerServoRotation + (Math.random() * 4 - 2);
      actualAmount += foodReleased;
      foodReductions++;

      const error = actualAmount - targetPortion;

      if (error < 0) continue;
      if (error >= CONFIG.errorThreshold) break;
      if (Math.abs(error) < CONFIG.errorThreshold) break;
    }

    return {
      actualAmount: Math.round(actualAmount),
      servoRotations,
      foodReductions,
      error: Math.round(actualAmount - targetPortion)
    };
  }

  // =======================
  // Feed Now: g·ªçi ESP32 th·∫≠t + c·∫≠p nh·∫≠t UI
  // =======================
  async function feedNow() {
    const btn = document.getElementById('feedNowBtn');
    const alertDiv = document.getElementById('feedAlert');
    const targetPortion = parseInt(portionSlider.value);

    // N·∫øu mu·ªën b·ªè check m√¥ ph·ªèng, b·∫°n c√≥ th·ªÉ x√≥a block n√†y.
    if (systemData.currentFood < targetPortion) {
      alertDiv.innerHTML = `
        <div class="alert alert-error">
          ‚ö†Ô∏è Kh√¥ng ƒë·ªß th·ª©c ƒÉn! C√≤n l·∫°i ${systemData.currentFood}g, c·∫ßn ${targetPortion}g
        </div>`;
      return;
    }

    btn.disabled = true;
    btn.innerHTML = '‚è≥ ƒêang cho ƒÉn...';
    alertDiv.innerHTML = '';

    // 1) G·ªåI ESP32 TH·∫¨T
    try {
      const j = await apiFeed();
      if (!j.ok) {
        alertDiv.innerHTML = `<div class="alert alert-warning">‚ö†Ô∏è ESP32 b·∫≠n: ${j.err || 'busy'}</div>`;
        btn.disabled = false;
        btn.innerHTML = 'üçΩÔ∏è Cho ƒÉn ngay';
        return;
      }
    } catch (e) {
      alertDiv.innerHTML = `<div class="alert alert-error">‚ùå Kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c ESP32</div>`;
      btn.disabled = false;
      btn.innerHTML = 'üçΩÔ∏è Cho ƒÉn ngay';
      setOnlineUI(false);
      return;
    }

    // 2) UI m√¥ ph·ªèng (ƒë·ªÉ c√≥ th·ªëng k√™ ƒë·∫πp). Servo th·∫≠t ƒë√£ ch·∫°y ·ªü b∆∞·ªõc tr√™n.
    await new Promise(resolve => setTimeout(resolve, 800));
    const result = simulateServoFeeding(targetPortion);

    systemData.currentFood -= result.actualAmount;
    if (systemData.currentFood < 0) systemData.currentFood = 0;

    const feedingRecord = {
      time: new Date().toLocaleTimeString('vi-VN'),
      timestamp: Date.now(),
      targetPortion,
      actualAmount: result.actualAmount,
      servoRotations: result.servoRotations,
      foodReductions: result.foodReductions,
      error: result.error,
      remainingFood: systemData.currentFood
    };
    systemData.todayFeedings.push(feedingRecord);
    saveData();

    let message = `
      <div class="alert alert-success">
        ‚úÖ ƒê√£ g·ª≠i l·ªánh cho ESP32 v√† ho√†n t·∫•t!<br>
        üéØ M·ª•c ti√™u: ${targetPortion}g | UI ∆∞·ªõc l∆∞·ª£ng: ${result.actualAmount}g<br>
        üîß Servo quay (∆∞·ªõc l∆∞·ª£ng): ${result.servoRotations} l·∫ßn<br>
        ${Math.abs(result.error) > 0 ? `üìä Sai s·ªë ∆∞·ªõc l∆∞·ª£ng: ${result.error > 0 ? '+' : ''}${result.error}g` : ''}
      </div>`;

    if (Math.abs(result.error) >= CONFIG.errorThreshold) {
      message = `
        <div class="alert alert-warning">
          ‚ö†Ô∏è ƒê√£ cho ƒÉn (ESP32) nh∆∞ng UI ∆∞·ªõc l∆∞·ª£ng sai s·ªë l·ªõn!<br>
          üéØ M·ª•c ti√™u: ${targetPortion}g | UI ∆∞·ªõc l∆∞·ª£ng: ${result.actualAmount}g<br>
          üìä Sai s·ªë ∆∞·ªõc l∆∞·ª£ng: ${result.error > 0 ? '+' : ''}${result.error}g (‚â• ${CONFIG.errorThreshold}g)
        </div>`;
    }

    alertDiv.innerHTML = message;
    updateAllDisplays();

    btn.disabled = false;
    btn.innerHTML = 'üçΩÔ∏è Cho ƒÉn ngay';

    // c·∫≠p nh·∫≠t status sau khi feed
    refreshFromESP();
  }

  // =======================
  // UI update functions
  // =======================
  function updateAllDisplays() {
    const foodPercent = Math.round((systemData.currentFood / CONFIG.totalCapacity) * 100);

    document.getElementById('foodDisplay').textContent = systemData.currentFood + 'g';
    document.getElementById('foodPercent').textContent = foodPercent + '%';
    document.getElementById('foodProgress').style.width = foodPercent + '%';
    document.getElementById('totalCapacity').textContent = CONFIG.totalCapacity + 'g';

    const todayCount = systemData.todayFeedings.length;
    const todayTotal = systemData.todayFeedings.reduce((sum, f) => sum + f.actualAmount, 0);
    const totalServo = systemData.todayFeedings.reduce((sum, f) => sum + f.servoRotations, 0);
    const totalReductions = systemData.todayFeedings.reduce((sum, f) => sum + f.foodReductions, 0);

    document.getElementById('todayFeeds').textContent = todayCount;
    document.getElementById('todayTotal').textContent = todayTotal + 'g';
    document.getElementById('servoCount').textContent = totalServo;

    document.getElementById('statTodayCount').textContent = todayCount;
    document.getElementById('statTodayAmount').textContent = todayTotal + 'g';
    document.getElementById('statServoRotations').textContent = totalServo;
    document.getElementById('statFoodReductions').textContent = totalReductions;

    const avgServo = todayCount > 0 ? Math.round((totalServo / todayCount) * 10) / 10 : 0;
    const avgFoodPerServo = totalServo > 0 ? Math.round((todayTotal / totalServo) * 10) / 10 : 0;

    document.getElementById('avgServoPerFeed').textContent = avgServo;
    document.getElementById('totalServoToday').textContent = totalServo;
    document.getElementById('avgFoodPerServo').textContent = avgFoodPerServo + 'g';

    updateFeedingHistory();
    updateUptime();
  }

  function updateFeedingHistory() {
    const historyDiv = document.getElementById('feedingHistory');

    if (systemData.todayFeedings.length === 0) {
      historyDiv.innerHTML = `
        <p style="text-align: center; color: var(--text-mid); padding: 20px;">
          Ch∆∞a c√≥ d·ªØ li·ªáu h√¥m nay
        </p>`;
      return;
    }

    const sorted = [...systemData.todayFeedings].reverse();

    historyDiv.innerHTML = sorted.map(feed => `
      <div class="history-item">
        <div>
          <div class="history-time">üïê ${feed.time}</div>
          <div class="history-servo">
            üîß Servo: ${feed.servoRotations} l·∫ßn |
            üìâ Gi·∫£m: ${feed.foodReductions} l·∫ßn
          </div>
        </div>
        <div style="text-align: right;">
          <div class="history-amount">
            ${feed.actualAmount}g
            ${feed.error !== 0 ? `<span style="font-size: 0.85rem; color: var(--text-mid);">(${feed.error > 0 ? '+' : ''}${feed.error}g)</span>` : ''}
          </div>
          <div style="font-size: 0.85rem; color: var(--text-mid);">
            M·ª•c ti√™u: ${feed.targetPortion}g
          </div>
        </div>
      </div>
    `).join('');
  }

  function updateUptime() {
    const uptime = Date.now() - systemData.connectionStats.startTime;
    const hours = Math.floor(uptime / 3600000);
    const minutes = Math.floor((uptime % 3600000) / 60000);
    document.getElementById('uptime').textContent = `${hours}h ${minutes}m`;
  }

  // =======================
  // Navigation (fix l·ªói event)
  // =======================
  function showPage(pageName) {
    document.querySelectorAll('.page-section').forEach(section => section.classList.remove('active'));
    document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));

    document.getElementById(pageName + '-page').classList.add('active');

    // FIX: kh√¥ng d√πng bi·∫øn event ng·∫ßm ƒë·ªãnh (hay l·ªói tr√™n m·ªôt s·ªë tr√¨nh duy·ªát)
    const btns = document.querySelectorAll('.nav-btn');
    btns.forEach(b => {
      if (b.getAttribute('onclick') && b.getAttribute('onclick').includes(`showPage('${pageName}')`)) {
        b.classList.add('active');
      }
    });

    if (pageName === 'statistics') updateAllDisplays();
  }

  // =======================
  // Schedule Modal
  // =======================
  function openScheduleModal() {
    document.getElementById('scheduleModal').classList.add('active');
  }

  function closeScheduleModal() {
    document.getElementById('scheduleModal').classList.remove('active');
  }

  function saveSchedule() {
    const time = document.getElementById('scheduleTime').value;
    const portion = parseInt(document.getElementById('schedulePortion').value);

    systemData.schedules.push({ id: Date.now(), time, portion });
    saveData();
    renderSchedules();
    closeScheduleModal();
    alert('‚úÖ ƒê√£ th√™m l·ªãch cho ƒÉn l√∫c ' + time + ' v·ªõi kh·∫©u ph·∫ßn ' + portion + 'g');
  }

  function renderSchedules() {
    const listDiv = document.getElementById('scheduleList');

    if (systemData.schedules.length === 0) {
      listDiv.innerHTML = `
        <p style="text-align: center; color: var(--text-mid); padding: 20px;">
          Ch∆∞a c√≥ l·ªãch n√†o. Nh·∫•n "Th√™m l·ªãch m·ªõi" ƒë·ªÉ t·∫°o.
        </p>`;
      return;
    }

    listDiv.innerHTML = systemData.schedules.map(schedule => `
      <div class="schedule-item">
        <div>
          <div class="schedule-time">${schedule.time}</div>
          <div style="color: var(--text-mid); font-size: 0.9rem; margin-top: 4px;">
            Kh·∫©u ph·∫ßn: ${schedule.portion}g
          </div>
        </div>
        <div class="schedule-actions">
          <button class="icon-btn icon-btn-delete" onclick="deleteSchedule(${schedule.id})">üóëÔ∏è</button>
        </div>
      </div>
    `).join('');
  }

  function deleteSchedule(id) {
    if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a l·ªãch n√†y?')) {
      systemData.schedules = systemData.schedules.filter(s => s.id !== id);
      saveData();
      renderSchedules();
    }
  }

  // =======================
  // Init
  // =======================
  window.addEventListener('load', () => {
    loadData();
    renderSchedules();
    refreshFromESP(); // g·ªçi status ngay khi m·ªü

    setInterval(() => {
      updateUptime();
      refreshFromESP();
    }, 1000);
  });
</script>
