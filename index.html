<script>
  // ==========================================================
  // PetFeeder UI Script (Safe + ESP32-friendly + no-blank-page)
  // ==========================================================

  // =======================
  // CONFIG
  // =======================
  const CONFIG = {
    totalCapacity: 1000,
    errorThreshold: 50,
    gramsPerServoRotation: 10,
    statusPollMs: 3000,   // polling status 3s ƒë·ªÉ ESP32 kh√¥ng ngh·∫Ωn
    uptimeTickMs: 1000,   // uptime 1s
    fetchTimeoutMs: 2500, // timeout status
    feedTimeoutMs: 4500,  // timeout feed
    defaultPage: 'dashboard' // ƒë·ªïi n·∫øu page m·∫∑c ƒë·ªãnh b·∫°n kh√°c
  };

  let systemData = {
    currentFood: CONFIG.totalCapacity,
    todayFeedings: [],
    schedules: [],
    connectionStats: {
      lastPing: 0,
      startTime: Date.now()
    }
  };

  // =======================
  // DOM SAFE HELPERS
  // =======================
  const $ = (id) => document.getElementById(id);

  function safeText(id, value) {
    const el = $(id);
    if (el) el.textContent = value;
  }

  function safeHTML(id, html) {
    const el = $(id);
    if (el) el.innerHTML = html;
  }

  function safeWidth(id, w) {
    const el = $(id);
    if (el) el.style.width = w;
  }

  // =======================
  // FETCH with TIMEOUT
  // =======================
  async function fetchWithTimeout(url, options = {}, timeoutMs = 2500) {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);

    try {
      const res = await fetch(url, {
        ...options,
        signal: ctrl.signal,
        cache: 'no-store'
      });
      return res;
    } finally {
      clearTimeout(t);
    }
  }

  // =======================
  // LocalStorage
  // =======================
  function loadData() {
    const saved = localStorage.getItem('petfeeder_data');
    if (saved) {
      try {
        const data = JSON.parse(saved);
        const today = new Date().toDateString();

        if (data.lastDate !== today) {
          systemData.todayFeedings = [];
          systemData.currentFood = CONFIG.totalCapacity;
          systemData.schedules = data.schedules ?? [];
        } else {
          systemData.currentFood = data.currentFood ?? CONFIG.totalCapacity;
          systemData.todayFeedings = data.todayFeedings ?? [];
          systemData.schedules = data.schedules ?? [];
        }
      } catch (e) {
        console.error('Error loading data:', e);
      }
    }
    updateAllDisplays();
  }

  function saveData() {
    const dataToSave = {
      currentFood: systemData.currentFood,
      todayFeedings: systemData.todayFeedings,
      schedules: systemData.schedules,
      lastDate: new Date().toDateString()
    };
    localStorage.setItem('petfeeder_data', JSON.stringify(dataToSave));
  }

  // =======================
  // ESP32 API
  // =======================
  async function apiStatus() {
    const t0 = performance.now();
    const r = await fetchWithTimeout('/api/status', {}, CONFIG.fetchTimeoutMs);
    const t1 = performance.now();

    if (!r.ok) throw new Error('status_http_' + r.status);

    const j = await r.json();
    systemData.connectionStats.lastPing = Math.round(t1 - t0);
    return j;
  }

  async function apiFeed() {
    const r = await fetchWithTimeout('/api/feed', { method: 'POST' }, CONFIG.feedTimeoutMs);
    if (!r.ok) throw new Error('feed_http_' + r.status);
    return await r.json();
  }

  function setOnlineUI(isOnline) {
    const badge = $('statusBadge');
    if (!badge) return;

    if (isOnline) {
      badge.textContent = 'Online';
      badge.classList.remove('status-offline');
      badge.classList.add('status-online');
    } else {
      badge.textContent = 'Offline';
      badge.classList.remove('status-online');
      badge.classList.add('status-offline');
    }
  }

  async function refreshFromESP() {
    try {
      const st = await apiStatus();
      setOnlineUI(true);

      safeText('pingTime', String(systemData.connectionStats.lastPing));
      safeText('lastUpdate', st.time || '---');
    } catch (e) {
      setOnlineUI(false);
      // im l·∫∑ng ƒë·ªÉ kh√¥ng l√†m ch·∫øt timer
    }
  }

  // =======================
  // Simulation (UI only)
  // =======================
  function simulateServoFeeding(targetPortion) {
    let actualAmount = 0;
    let servoRotations = 0;
    let foodReductions = 0;

    while (actualAmount < targetPortion) {
      servoRotations++;
      const foodReleased = CONFIG.gramsPerServoRotation + (Math.random() * 4 - 2);
      actualAmount += foodReleased;
      foodReductions++;

      const error = actualAmount - targetPortion;

      if (error < 0) continue;
      if (error >= CONFIG.errorThreshold) break;
      if (Math.abs(error) < CONFIG.errorThreshold) break;
    }

    return {
      actualAmount: Math.round(actualAmount),
      servoRotations,
      foodReductions,
      error: Math.round(actualAmount - targetPortion)
    };
  }

  // =======================
  // FEED NOW
  // =======================
  async function feedNow() {
    const btn = $('feedNowBtn');
    const alertDiv = $('feedAlert');
    const slider = $('portionSlider');

    if (!slider) {
      if (alertDiv) alertDiv.innerHTML = `<div class="alert alert-error">‚ùå Thi·∫øu #portionSlider trong HTML</div>`;
      return;
    }

    const targetPortion = parseInt(slider.value, 10);
    if (!Number.isFinite(targetPortion) || targetPortion <= 0) {
      if (alertDiv) alertDiv.innerHTML = `<div class="alert alert-warning">‚ö†Ô∏è Kh·∫©u ph·∫ßn kh√¥ng h·ª£p l·ªá</div>`;
      return;
    }

    // check t·ªìn kho UI
    if (systemData.currentFood < targetPortion) {
      if (alertDiv) {
        alertDiv.innerHTML = `
          <div class="alert alert-error">
            ‚ö†Ô∏è Kh√¥ng ƒë·ªß th·ª©c ƒÉn! C√≤n l·∫°i ${systemData.currentFood}g, c·∫ßn ${targetPortion}g
          </div>`;
      }
      return;
    }

    if (btn) {
      btn.disabled = true;
      btn.innerHTML = '‚è≥ ƒêang cho ƒÉn...';
    }
    if (alertDiv) alertDiv.innerHTML = '';

    // 1) g·ªçi ESP32 th·∫≠t
    try {
      const j = await apiFeed();
      if (!j || j.ok !== true) {
        if (alertDiv) alertDiv.innerHTML =
          `<div class="alert alert-warning">‚ö†Ô∏è ESP32 b·∫≠n: ${(j && j.err) ? j.err : 'busy'}</div>`;
        if (btn) { btn.disabled = false; btn.innerHTML = 'üçΩÔ∏è Cho ƒÉn ngay'; }
        return;
      }
    } catch (e) {
      if (alertDiv) alertDiv.innerHTML = `<div class="alert alert-error">‚ùå Kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c ESP32</div>`;
      if (btn) { btn.disabled = false; btn.innerHTML = 'üçΩÔ∏è Cho ƒÉn ngay'; }
      setOnlineUI(false);
      return;
    }

    // 2) m√¥ ph·ªèng UI ƒë·ªÉ th·ªëng k√™
    await new Promise(r => setTimeout(r, 600));
    const result = simulateServoFeeding(targetPortion);

    systemData.currentFood -= result.actualAmount;
    if (systemData.currentFood < 0) systemData.currentFood = 0;

    const feedingRecord = {
      time: new Date().toLocaleTimeString('vi-VN'),
      timestamp: Date.now(),
      targetPortion,
      actualAmount: result.actualAmount,
      servoRotations: result.servoRotations,
      foodReductions: result.foodReductions,
      error: result.error,
      remainingFood: systemData.currentFood
    };

    systemData.todayFeedings.push(feedingRecord);
    saveData();

    let message = `
      <div class="alert alert-success">
        ‚úÖ ƒê√£ g·ª≠i l·ªánh cho ESP32 v√† ho√†n t·∫•t!<br>
        üéØ M·ª•c ti√™u: ${targetPortion}g | UI ∆∞·ªõc l∆∞·ª£ng: ${result.actualAmount}g<br>
        üîß Servo quay (∆∞·ªõc l∆∞·ª£ng): ${result.servoRotations} l·∫ßn<br>
        ${Math.abs(result.error) > 0 ? `üìä Sai s·ªë ∆∞·ªõc l∆∞·ª£ng: ${result.error > 0 ? '+' : ''}${result.error}g` : ''}
      </div>`;

    if (Math.abs(result.error) >= CONFIG.errorThreshold) {
      message = `
        <div class="alert alert-warning">
          ‚ö†Ô∏è ƒê√£ cho ƒÉn (ESP32) nh∆∞ng UI ∆∞·ªõc l∆∞·ª£ng sai s·ªë l·ªõn!<br>
          üéØ M·ª•c ti√™u: ${targetPortion}g | UI ∆∞·ªõc l∆∞·ª£ng: ${result.actualAmount}g<br>
          üìä Sai s·ªë ∆∞·ªõc l∆∞·ª£ng: ${result.error > 0 ? '+' : ''}${result.error}g (‚â• ${CONFIG.errorThreshold}g)
        </div>`;
    }

    if (alertDiv) alertDiv.innerHTML = message;

    updateAllDisplays();

    if (btn) {
      btn.disabled = false;
      btn.innerHTML = 'üçΩÔ∏è Cho ƒÉn ngay';
    }

    refreshFromESP();
  }

  // =======================
  // UI UPDATES
  // =======================
  function updateAllDisplays() {
    const foodPercent = Math.round((systemData.currentFood / CONFIG.totalCapacity) * 100);

    safeText('foodDisplay', systemData.currentFood + 'g');
    safeText('foodPercent', foodPercent + '%');
    safeWidth('foodProgress', foodPercent + '%');
    safeText('totalCapacity', CONFIG.totalCapacity + 'g');

    const todayCount = systemData.todayFeedings.length;
    const todayTotal = systemData.todayFeedings.reduce((sum, f) => sum + (f.actualAmount || 0), 0);
    const totalServo = systemData.todayFeedings.reduce((sum, f) => sum + (f.servoRotations || 0), 0);
    const totalReductions = systemData.todayFeedings.reduce((sum, f) => sum + (f.foodReductions || 0), 0);

    safeText('todayFeeds', String(todayCount));
    safeText('todayTotal', todayTotal + 'g');
    safeText('servoCount', String(totalServo));

    safeText('statTodayCount', String(todayCount));
    safeText('statTodayAmount', todayTotal + 'g');
    safeText('statServoRotations', String(totalServo));
    safeText('statFoodReductions', String(totalReductions));

    const avgServo = todayCount > 0 ? Math.round((totalServo / todayCount) * 10) / 10 : 0;
    const avgFoodPerServo = totalServo > 0 ? Math.round((todayTotal / totalServo) * 10) / 10 : 0;

    safeText('avgServoPerFeed', String(avgServo));
    safeText('totalServoToday', String(totalServo));
    safeText('avgFoodPerServo', avgFoodPerServo + 'g');

    updateFeedingHistory();
    updateUptime();
  }

  function updateFeedingHistory() {
    const historyDiv = $('feedingHistory');
    if (!historyDiv) return;

    if (systemData.todayFeedings.length === 0) {
      historyDiv.innerHTML = `
        <p style="text-align: center; color: var(--text-mid); padding: 20px;">
          Ch∆∞a c√≥ d·ªØ li·ªáu h√¥m nay
        </p>`;
      return;
    }

    const sorted = [...systemData.todayFeedings].reverse();

    historyDiv.innerHTML = sorted.map(feed => `
      <div class="history-item">
        <div>
          <div class="history-time">üïê ${feed.time}</div>
          <div class="history-servo">
            üîß Servo: ${feed.servoRotations} l·∫ßn |
            üìâ Gi·∫£m: ${feed.foodReductions} l·∫ßn
          </div>
        </div>
        <div style="text-align: right;">
          <div class="history-amount">
            ${feed.actualAmount}g
            ${feed.error !== 0
              ? `<span style="font-size: 0.85rem; color: var(--text-mid);">(${feed.error > 0 ? '+' : ''}${feed.error}g)</span>`
              : ''
            }
          </div>
          <div style="font-size: 0.85rem; color: var(--text-mid);">
            M·ª•c ti√™u: ${feed.targetPortion}g
          </div>
        </div>
      </div>
    `).join('');
  }

  function updateUptime() {
    const el = $('uptime');
    if (!el) return;

    const uptime = Date.now() - systemData.connectionStats.startTime;
    const hours = Math.floor(uptime / 3600000);
    const minutes = Math.floor((uptime % 3600000) / 60000);
    el.textContent = `${hours}h ${minutes}m`;
  }

  // =======================
  // NAVIGATION (no blank page)
  // =======================
  function showPage(pageName) {
    // ·∫©n t·∫•t c·∫£
    document.querySelectorAll('.page-section').forEach(s => s.classList.remove('active'));
    document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));

    // hi·ªán page ƒë∆∞·ª£c y√™u c·∫ßu
    const page = $(pageName + '-page');
    if (page) page.classList.add('active');

    // active n√∫t nav (n·∫øu v·∫´n d√πng onclick trong HTML)
    document.querySelectorAll('.nav-btn').forEach(b => {
      const oc = b.getAttribute('onclick') || '';
      if (oc.includes(`showPage('${pageName}')`)) b.classList.add('active');
    });

    // n·∫øu l√† statistics th√¨ refresh
    if (pageName === 'statistics') updateAllDisplays();
  }

  // fallback: b·∫≠t page ƒë·∫ßu ti√™n n·∫øu pageName sai
  function ensureVisiblePage() {
    const anyActive = document.querySelector('.page-section.active');
    if (anyActive) return true;

    // th·ª≠ b·∫≠t defaultPage
    const def = $(CONFIG.defaultPage + '-page');
    if (def) {
      def.classList.add('active');
      return true;
    }

    // b·∫≠t section ƒë·∫ßu ti√™n
    const first = document.querySelector('.page-section');
    if (first) {
      first.classList.add('active');
      return true;
    }
    return false;
  }

  // =======================
  // SCHEDULE MODAL
  // =======================
  function openScheduleModal() {
    const m = $('scheduleModal');
    if (m) m.classList.add('active');
  }

  function closeScheduleModal() {
    const m = $('scheduleModal');
    if (m) m.classList.remove('active');
  }

  function saveSchedule() {
    const timeEl = $('scheduleTime');
    const portionEl = $('schedulePortion');
    if (!timeEl || !portionEl) return;

    const time = timeEl.value;
    const portion = parseInt(portionEl.value, 10);

    if (!time || !Number.isFinite(portion) || portion <= 0) {
      alert('‚ö†Ô∏è Th·ªùi gian/kh·∫©u ph·∫ßn kh√¥ng h·ª£p l·ªá');
      return;
    }

    systemData.schedules.push({ id: Date.now(), time, portion });
    saveData();
    renderSchedules();
    closeScheduleModal();
    alert('‚úÖ ƒê√£ th√™m l·ªãch cho ƒÉn l√∫c ' + time + ' v·ªõi kh·∫©u ph·∫ßn ' + portion + 'g');
  }

  function renderSchedules() {
    const listDiv = $('scheduleList');
    if (!listDiv) return;

    if (systemData.schedules.length === 0) {
      listDiv.innerHTML = `
        <p style="text-align: center; color: var(--text-mid); padding: 20px;">
          Ch∆∞a c√≥ l·ªãch n√†o. Nh·∫•n "Th√™m l·ªãch m·ªõi" ƒë·ªÉ t·∫°o.
        </p>`;
      return;
    }

    listDiv.innerHTML = systemData.schedules.map(s => `
      <div class="schedule-item">
        <div>
          <div class="schedule-time">${s.time}</div>
          <div style="color: var(--text-mid); font-size: 0.9rem; margin-top: 4px;">
            Kh·∫©u ph·∫ßn: ${s.portion}g
          </div>
        </div>
        <div class="schedule-actions">
          <button class="icon-btn icon-btn-delete" onclick="deleteSchedule(${s.id})">üóëÔ∏è</button>
        </div>
      </div>
    `).join('');
  }

  function deleteSchedule(id) {
    if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a l·ªãch n√†y?')) {
      systemData.schedules = systemData.schedules.filter(s => s.id !== id);
      saveData();
      renderSchedules();
    }
  }

  // =======================
  // INIT (guarantee UI shows)
  // =======================
  window.addEventListener('load', () => {
    // N·∫øu CSS/JS tr∆∞·ªõc ƒë√≥ c√≥ ·∫©n body th√¨ m·ªü l·∫°i
    document.body.style.visibility = 'visible';
    document.body.style.opacity = '1';

    // ƒë·∫£m b·∫£o c√≥ 1 page hi·ªÉn th·ªã -> tr√°nh tr·∫Øng trang
    ensureVisiblePage();

    // setup slider an to√†n
    const slider = $('portionSlider');
    const display = $('portionDisplay');
    if (slider && display) {
      display.textContent = slider.value + 'g';
      slider.addEventListener('input', function () {
        display.textContent = this.value + 'g';
      });
    }

    // load UI data
    loadData();
    renderSchedules();

    // c·∫£nh b√°o n·∫øu ƒëang m·ªü file:// (kh√¥ng g·ªçi ƒë∆∞·ª£c /api tr√™n local file)
    if (location.protocol === 'file:') {
      console.warn('B·∫°n ƒëang m·ªü b·∫±ng file://. Mu·ªën ch·∫°y ESP32 API th√¨ h√£y m·ªü qua http://<ip-esp32>/');
      // v·∫´n cho UI ch·∫°y local, nh∆∞ng status s·∫Ω offline.
      setOnlineUI(false);
    } else {
      refreshFromESP();
    }

    // timers: uptime 1s, status 3s
    setInterval(updateUptime, CONFIG.uptimeTickMs);
    setInterval(() => {
      if (location.protocol !== 'file:') refreshFromESP();
    }, CONFIG.statusPollMs);
  });

  // =======================
  // EXPORT for onclick in HTML
  // =======================
  window.feedNow = feedNow;
  window.showPage = showPage;
  window.openScheduleModal = openScheduleModal;
  window.closeScheduleModal = closeScheduleModal;
  window.saveSchedule = saveSchedule;
  window.renderSchedules = renderSchedules;
  window.deleteSchedule = deleteSchedule;
</script>
