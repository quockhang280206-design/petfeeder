<script>
  // =======================
  // CONFIG
  // =======================
  const CONFIG = {
    totalCapacity: 1000,
    errorThreshold: 50,
    gramsPerServoRotation: 10
  };

  let systemData = {
    currentFood: CONFIG.totalCapacity,
    todayFeedings: [],
    schedules: [],
    connectionStats: {
      lastPing: 0,
      startTime: Date.now()
    }
  };

  // =======================
  // DOM helpers (ch·ªëng crash)
  // =======================
  const $ = (id) => document.getElementById(id);

  function setText(id, text) {
    const el = $(id);
    if (el) el.textContent = text;
  }

  function setHTML(id, html) {
    const el = $(id);
    if (el) el.innerHTML = html;
  }

  function setWidth(id, w) {
    const el = $(id);
    if (el) el.style.width = w;
  }

  // =======================
  // Fetch helper (timeout)
  // =======================
  async function fetchWithTimeout(url, options = {}, timeoutMs = 2500) {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const res = await fetch(url, { ...options, signal: ctrl.signal, cache: 'no-store' });
      return res;
    } finally {
      clearTimeout(t);
    }
  }

  // ============
  // LocalStorage
  // ============
  function loadData() {
    const saved = localStorage.getItem('petfeeder_data');
    if (saved) {
      try {
        const data = JSON.parse(saved);
        const today = new Date().toDateString();

        if (data.lastDate !== today) {
          systemData.todayFeedings = [];
          systemData.currentFood = CONFIG.totalCapacity;
          systemData.schedules = data.schedules ?? [];
        } else {
          systemData.currentFood = data.currentFood ?? CONFIG.totalCapacity;
          systemData.todayFeedings = data.todayFeedings ?? [];
          systemData.schedules = data.schedules ?? [];
        }
      } catch (e) {
        console.error('Error loading data:', e);
      }
    }
    updateAllDisplays();
  }

  function saveData() {
    const dataToSave = {
      currentFood: systemData.currentFood,
      todayFeedings: systemData.todayFeedings,
      schedules: systemData.schedules,
      lastDate: new Date().toDateString()
    };
    localStorage.setItem('petfeeder_data', JSON.stringify(dataToSave));
  }

  // =======================
  // ESP32 API helpers
  // =======================
  async function apiStatus() {
    const t0 = performance.now();
    const r = await fetchWithTimeout('/api/status', {}, 2500);
    const t1 = performance.now();

    if (!r.ok) throw new Error('status_http_' + r.status);

    const j = await r.json();
    systemData.connectionStats.lastPing = Math.round(t1 - t0);
    return j;
  }

  async function apiFeed() {
    const r = await fetchWithTimeout('/api/feed', { method: 'POST' }, 4000);
    if (!r.ok) throw new Error('feed_http_' + r.status);
    return await r.json();
  }

  function setOnlineUI(isOnline) {
    const badge = $('statusBadge');
    if (!badge) return;

    if (isOnline) {
      badge.textContent = 'Online';
      badge.classList.remove('status-offline');
      badge.classList.add('status-online');
    } else {
      badge.textContent = 'Offline';
      badge.classList.remove('status-online');
      badge.classList.add('status-offline');
    }
  }

  async function refreshFromESP() {
    try {
      const st = await apiStatus();
      setOnlineUI(true);

      setText('pingTime', String(systemData.connectionStats.lastPing));
      setText('lastUpdate', st.time || '---');
    } catch (e) {
      setOnlineUI(false);
      // kh√¥ng throw ƒë·ªÉ tr√°nh l√†m ch·∫øt timer
    }
  }

  // =======================
  // M√¥ ph·ªèng (UI th·ªëng k√™)
  // =======================
  function simulateServoFeeding(targetPortion) {
    let actualAmount = 0;
    let servoRotations = 0;
    let foodReductions = 0;

    while (actualAmount < targetPortion) {
      servoRotations++;
      const foodReleased = CONFIG.gramsPerServoRotation + (Math.random() * 4 - 2);
      actualAmount += foodReleased;
      foodReductions++;

      const error = actualAmount - targetPortion;

      if (error < 0) continue;
      if (error >= CONFIG.errorThreshold) break;
      if (Math.abs(error) < CONFIG.errorThreshold) break;
    }

    return {
      actualAmount: Math.round(actualAmount),
      servoRotations,
      foodReductions,
      error: Math.round(actualAmount - targetPortion)
    };
  }

  // =======================
  // Feed Now
  // =======================
  async function feedNow() {
    const btn = $('feedNowBtn');
    const alertDiv = $('feedAlert');

    // slider c√≥ th·ªÉ ch∆∞a c√≥ -> ch·∫∑n
    const portionSlider = $('portionSlider');
    if (!portionSlider) {
      if (alertDiv) alertDiv.innerHTML = `<div class="alert alert-error">‚ùå Thi·∫øu ph·∫ßn t·ª≠ #portionSlider trong HTML</div>`;
      return;
    }

    const targetPortion = parseInt(portionSlider.value, 10);
    if (!Number.isFinite(targetPortion) || targetPortion <= 0) {
      if (alertDiv) alertDiv.innerHTML = `<div class="alert alert-warning">‚ö†Ô∏è Kh·∫©u ph·∫ßn kh√¥ng h·ª£p l·ªá</div>`;
      return;
    }

    // check m√¥ ph·ªèng t·ªìn kho UI
    if (systemData.currentFood < targetPortion) {
      if (alertDiv) {
        alertDiv.innerHTML = `
          <div class="alert alert-error">
            ‚ö†Ô∏è Kh√¥ng ƒë·ªß th·ª©c ƒÉn! C√≤n l·∫°i ${systemData.currentFood}g, c·∫ßn ${targetPortion}g
          </div>`;
      }
      return;
    }

    if (btn) {
      btn.disabled = true;
      btn.innerHTML = '‚è≥ ƒêang cho ƒÉn...';
    }
    if (alertDiv) alertDiv.innerHTML = '';

    // 1) G·ªåI ESP32 TH·∫¨T
    try {
      const j = await apiFeed();

      // k·ª≥ v·ªçng ESP32 tr·∫£ { ok: true } ho·∫∑c { ok:false, err:"busy" }
      if (!j || j.ok !== true) {
        if (alertDiv) alertDiv.innerHTML =
          `<div class="alert alert-warning">‚ö†Ô∏è ESP32 b·∫≠n: ${(j && j.err) ? j.err : 'busy'}</div>`;
        if (btn) { btn.disabled = false; btn.innerHTML = 'üçΩÔ∏è Cho ƒÉn ngay'; }
        return;
      }
    } catch (e) {
      if (alertDiv) alertDiv.innerHTML = `<div class="alert alert-error">‚ùå Kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c ESP32</div>`;
      if (btn) { btn.disabled = false; btn.innerHTML = 'üçΩÔ∏è Cho ƒÉn ngay'; }
      setOnlineUI(false);
      return;
    }

    // 2) UI m√¥ ph·ªèng ƒë·ªÉ c√≥ th·ªëng k√™
    await new Promise(resolve => setTimeout(resolve, 800));
    const result = simulateServoFeeding(targetPortion);

    systemData.currentFood -= result.actualAmount;
    if (systemData.currentFood < 0) systemData.currentFood = 0;

    const feedingRecord = {
      time: new Date().toLocaleTimeString('vi-VN'),
      timestamp: Date.now(),
      targetPortion,
      actualAmount: result.actualAmount,
      servoRotations: result.servoRotations,
      foodReductions: result.foodReductions,
      error: result.error,
      remainingFood: systemData.currentFood
    };
    systemData.todayFeedings.push(feedingRecord);
    saveData();

    let message = `
      <div class="alert alert-success">
        ‚úÖ ƒê√£ g·ª≠i l·ªánh cho ESP32 v√† ho√†n t·∫•t!<br>
        üéØ M·ª•c ti√™u: ${targetPortion}g | UI ∆∞·ªõc l∆∞·ª£ng: ${result.actualAmount}g<br>
        üîß Servo quay (∆∞·ªõc l∆∞·ª£ng): ${result.servoRotations} l·∫ßn<br>
        ${Math.abs(result.error) > 0 ? `üìä Sai s·ªë ∆∞·ªõc l∆∞·ª£ng: ${result.error > 0 ? '+' : ''}${result.error}g` : ''}
      </div>`;

    if (Math.abs(result.error) >= CONFIG.errorThreshold) {
      message = `
        <div class="alert alert-warning">
          ‚ö†Ô∏è ƒê√£ cho ƒÉn (ESP32) nh∆∞ng UI ∆∞·ªõc l∆∞·ª£ng sai s·ªë l·ªõn!<br>
          üéØ M·ª•c ti√™u: ${targetPortion}g | UI ∆∞·ªõc l∆∞·ª£ng: ${result.actualAmount}g<br>
          üìä Sai s·ªë ∆∞·ªõc l∆∞·ª£ng: ${result.error > 0 ? '+' : ''}${result.error}g (‚â• ${CONFIG.errorThreshold}g)
        </div>`;
    }

    if (alertDiv) alertDiv.innerHTML = message;
    updateAllDisplays();

    if (btn) {
      btn.disabled = false;
      btn.innerHTML = 'üçΩÔ∏è Cho ƒÉn ngay';
    }

    refreshFromESP();
  }

  // =======================
  // UI update
  // =======================
  function updateAllDisplays() {
    const foodPercent = Math.round((systemData.currentFood / CONFIG.totalCapacity) * 100);

    setText('foodDisplay', systemData.currentFood + 'g');
    setText('foodPercent', foodPercent + '%');
    setWidth('foodProgress', foodPercent + '%');
    setText('totalCapacity', CONFIG.totalCapacity + 'g');

    const todayCount = systemData.todayFeedings.length;
    const todayTotal = systemData.todayFeedings.reduce((sum, f) => sum + (f.actualAmount || 0), 0);
    const totalServo = systemData.todayFeedings.reduce((sum, f) => sum + (f.servoRotations || 0), 0);
    const totalReductions = systemData.todayFeedings.reduce((sum, f) => sum + (f.foodReductions || 0), 0);

    setText('todayFeeds', String(todayCount));
    setText('todayTotal', todayTotal + 'g');
    setText('servoCount', String(totalServo));

    setText('statTodayCount', String(todayCount));
    setText('statTodayAmount', todayTotal + 'g');
    setText('statServoRotations', String(totalServo));
    setText('statFoodReductions', String(totalReductions));

    const avgServo = todayCount > 0 ? Math.round((totalServo / todayCount) * 10) / 10 : 0;
    const avgFoodPerServo = totalServo > 0 ? Math.round((todayTotal / totalServo) * 10) / 10 : 0;

    setText('avgServoPerFeed', String(avgServo));
    setText('totalServoToday', String(totalServo));
    setText('avgFoodPerServo', avgFoodPerServo + 'g');

    updateFeedingHistory();
    updateUptime();
  }

  function updateFeedingHistory() {
    const historyDiv = $('feedingHistory');
    if (!historyDiv) return;

    if (systemData.todayFeedings.length === 0) {
      historyDiv.innerHTML = `
        <p style="text-align: center; color: var(--text-mid); padding: 20px;">
          Ch∆∞a c√≥ d·ªØ li·ªáu h√¥m nay
        </p>`;
      return;
    }

    const sorted = [...systemData.todayFeedings].reverse();

    historyDiv.innerHTML = sorted.map(feed => `
      <div class="history-item">
        <div>
          <div class="history-time">üïê ${feed.time}</div>
          <div class="history-servo">
            üîß Servo: ${feed.servoRotations} l·∫ßn |
            üìâ Gi·∫£m: ${feed.foodReductions} l·∫ßn
          </div>
        </div>
        <div style="text-align: right;">
          <div class="history-amount">
            ${feed.actualAmount}g
            ${feed.error !== 0
              ? `<span style="font-size: 0.85rem; color: var(--text-mid);">(${feed.error > 0 ? '+' : ''}${feed.error}g)</span>`
              : ''
            }
          </div>
          <div style="font-size: 0.85rem; color: var(--text-mid);">
            M·ª•c ti√™u: ${feed.targetPortion}g
          </div>
        </div>
      </div>
    `).join('');
  }

  function updateUptime() {
    const el = $('uptime');
    if (!el) return;

    const uptime = Date.now() - systemData.connectionStats.startTime;
    const hours = Math.floor(uptime / 3600000);
    const minutes = Math.floor((uptime % 3600000) / 60000);
    el.textContent = `${hours}h ${minutes}m`;
  }

  // =======================
  // Navigation
  // =======================
  function showPage(pageName) {
    document.querySelectorAll('.page-section').forEach(section => section.classList.remove('active'));
    document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));

    const page = $(pageName + '-page');
    if (page) page.classList.add('active');

    const btns = document.querySelectorAll('.nav-btn');
    btns.forEach(b => {
      const oc = b.getAttribute('onclick') || '';
      if (oc.includes(`showPage('${pageName}')`)) b.classList.add('active');
    });

    if (pageName === 'statistics') updateAllDisplays();
  }

  // =======================
  // Schedule Modal
  // =======================
  function openScheduleModal() {
    const m = $('scheduleModal');
    if (m) m.classList.add('active');
  }

  function closeScheduleModal() {
    const m = $('scheduleModal');
    if (m) m.classList.remove('active');
  }

  function saveSchedule() {
    const timeEl = $('scheduleTime');
    const portionEl = $('schedulePortion');
    if (!timeEl || !portionEl) return;

    const time = timeEl.value;
    const portion = parseInt(portionEl.value, 10);

    if (!time || !Number.isFinite(portion) || portion <= 0) {
      alert('‚ö†Ô∏è Th·ªùi gian/kh·∫©u ph·∫ßn kh√¥ng h·ª£p l·ªá');
      return;
    }

    systemData.schedules.push({ id: Date.now(), time, portion });
    saveData();
    renderSchedules();
    closeScheduleModal();
    alert('‚úÖ ƒê√£ th√™m l·ªãch cho ƒÉn l√∫c ' + time + ' v·ªõi kh·∫©u ph·∫ßn ' + portion + 'g');
  }

  function renderSchedules() {
    const listDiv = $('scheduleList');
    if (!listDiv) return;

    if (systemData.schedules.length === 0) {
      listDiv.innerHTML = `
        <p style="text-align: center; color: var(--text-mid); padding: 20px;">
          Ch∆∞a c√≥ l·ªãch n√†o. Nh·∫•n "Th√™m l·ªãch m·ªõi" ƒë·ªÉ t·∫°o.
        </p>`;
      return;
    }

    listDiv.innerHTML = systemData.schedules.map(schedule => `
      <div class="schedule-item">
        <div>
          <div class="schedule-time">${schedule.time}</div>
          <div style="color: var(--text-mid); font-size: 0.9rem; margin-top: 4px;">
            Kh·∫©u ph·∫ßn: ${schedule.portion}g
          </div>
        </div>
        <div class="schedule-actions">
          <button class="icon-btn icon-btn-delete" onclick="deleteSchedule(${schedule.id})">üóëÔ∏è</button>
        </div>
      </div>
    `).join('');
  }

  function deleteSchedule(id) {
    if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a l·ªãch n√†y?')) {
      systemData.schedules = systemData.schedules.filter(s => s.id !== id);
      saveData();
      renderSchedules();
    }
  }

  // =======================
  // Init (kh√¥ng l√†m ch·∫øt UI)
  // =======================
  window.addEventListener('load', () => {
    // Slider setup an to√†n
    const portionSlider = $('portionSlider');
    const portionDisplay = $('portionDisplay');
    if (portionSlider && portionDisplay) {
      portionDisplay.textContent = portionSlider.value + 'g';
      portionSlider.addEventListener('input', function () {
        portionDisplay.textContent = this.value + 'g';
      });
    }

    loadData();
    renderSchedules();
    refreshFromESP();

    // uptime 1s, status 3s (ƒë·ª° ngh·∫Ωn ESP32)
    setInterval(updateUptime, 1000);
    setInterval(refreshFromESP, 3000);
  });

  // =======================
  // Export ƒë·ªÉ d√πng trong onclick HTML
  // =======================
  window.feedNow = feedNow;
  window.showPage = showPage;
  window.openScheduleModal = openScheduleModal;
  window.closeScheduleModal = closeScheduleModal;
  window.saveSchedule = saveSchedule;
  window.deleteSchedule = deleteSchedule;
</script>
